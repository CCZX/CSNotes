
[根据身高重建队列-力扣](https://leetcode-cn.com/problems/queue-reconstruction-by-height)
<span style="color: #FFB73F">中等</span>

### 题目描述

假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对`(h, k)`表示，其中h是这个人的身高，`k`是排在这个人前面且身高大于或等于`h`的人数。 编写一个算法来重建这个队列。

**注意：**
总人数少于`1100`人。

### 输入输出示例

```js
输入:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

输出:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```
`[[7, 0], [7, 1], [6, 1], [5, 0], [5, 2], [4, 4]]`
### 解题方法

#### 1、贪婪算法

我们最后得到的数组，假设`k[x]`表示第`x`项的身高，`h[x]`表示前面`x - 1`项的`k[i](1 <= i <= x - 1)`大于等于`k[x]`之和的数量。

对于任意第`n`项，满足条件：
```js
while(1 <= i <= n - 1) {
  sum(k[i] > k[n]) = h[n]
}
```

- 所以我们按照`k`从大到小排序，因为只有这样才能尽可能的满足后面后面的项。
- 对于`k`相同的我们按照`h`从小到大排序。

**exp：**
对于数组：`[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]`，我们排序后得到：`[[7, 0], [7, 1], [6, 1], [5, 0], [5, 2], [4, 4]]`


然后我们遍历排序后的数组，**按照`h`的值作为数组索引，将其放入新的数组之中**，如果新的数组该索引已有值，则将其后面的值**依次后移**。

> 代码实现：

```js
/**
 * @param {number[][]} people
 * @return {number[][]}
 */
var reconstructQueue = function(people) {
  let res = [];
  if(people.length === 0) return []
  people.sort((a, b) => {
    return a[0] !== b[0] ? b[0] - a[0] : a[1] - b[1]
  })
  people.forEach(item=>{
    res.splice(item[1], 0, item)
  })
  return res;
};

```

> 时间复杂度&空间复杂度：
- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`

> 执行结果：

- 执行用时：`92 ms`，在所有`JavaScript`提交中击败了`99.61 %`的用户
- 内存消耗：`42 MB`，在所有`JavaScript`提交中击败了`85.61 %`的用户
