<script>
  /*
    一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
    机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
    现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
    网格中的障碍物和空位置分别用 1 和 0 来表示。
    说明：m 和 n 的值均不超过 100。
  
    输入:
    [
      [0,0,0],
      [0,1,0],
      [0,0,0]
    ]
    输出: 2
    解释:
    3x3 网格的正中间有一个障碍物。
    从左上角到右下角一共有 2 条不同的路径：
    1. 向右 -> 向右 -> 向下 -> 向下
    2. 向下 -> 向下 -> 向右 -> 向右
  */
  /**
   * @param {number[][]} obstacleGrid
   * @return {number}
   */
  const uniquePathsWithObstacles = function (obstacleGrid) {
    if (obstacleGrid[0][0] === 1) {
      return 0
    }
    const m = obstacleGrid.length
    const n = obstacleGrid[0].length
    const dp = Array(m).fill(0).map(item => {
      return Array(n).fill(0)
    })
    for (let i = 0; i < n; i++) {
      if (obstacleGrid[0][n] === 1) {
        break
      }
      dp[0][n] = 1
    }
    for (let i = 0; i < m; i++) {
      if (obstacleGrid[m][0] === 1) {
        break
      }
      dp[m][0] = 1
    }
    // 记录一下第一列的值
    const firstColumn = obstacleGrid.map(item => item[0])
    for (let i = 0; i < m; i++) {
      for (let j = 0; j < n; j++) {
        // 第一列、第一行做特殊处理
        if (i === 0 || j === 0) {
          if (obstacleGrid[i][j] === 1) {
            // 如果第一行的某一项为1（有障碍），则第一行后面所有的项的路径都为0（对应dp的项为0）
            if (i === 0) {
              break
            }
          } else {
            // 如果是第一列，则该列前面不能有路障，否则到达路径为0
            if (j === 0) {
              dp[i][j] = firstColumn.slice(0, i).indexOf(1) === -1 ? 1 : 0
            } else {
              dp[i][j] = 1
            }
          }
        } else {
          if (obstacleGrid[i][j] === 1) {
            dp[i][j] = 0
          } else {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
          }
        }
      }
    }
    // console.log(dp, firstColumn)
    return dp[m - 1][n - 1]
  }
  // [
  //   [0,0],
  //   [1,1],
  //   [0,0]
  // ]
  // console.log(uniquePathsWithObstacles([[0,0],[1,1],[0,0]]))

  /**
   * @param {number[][]} obstacleGrid
   * @return {number}
   */
  var uniquePathsWithObstacles1 = function (obstacleGrid) {
    const rowCount = obstacleGrid.length;
    const colCount = obstacleGrid[0].length;

    if (obstacleGrid[0][0] === 1 || obstacleGrid[rowCount - 1][colCount - 1] === 1) {
      return 0;
    }

    let dp = [];
    for (let col = 0; col < colCount; col++) {
      dp[col] = (col > 0 && dp[col - 1] === 0) || obstacleGrid[0][col] === 1 ? 0 : 1;
    }
    console.log(dp)
    for (let row = 1; row < rowCount; row++) {
      for (let col = 0; col < colCount; col++) {
        if (obstacleGrid[row][col] === 1) {
          dp[col] = 0;
        } else {
          dp[col] += dp[col - 1] || 0;
        }
      }
    }
    console.log(dp)
    return dp[colCount - 1];
  };
  console.log(uniquePathsWithObstacles1([[0, 0], [1, 1], [0, 0]]))

</script>