### 题目

[打家劫舍-力扣](https://leetcode-cn.com/problems/house-robber)
简单

### 题目描述
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

### 输入输出示例

示例 1：
```js
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

示例 2：
```js
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

### 说明
- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

### 解题方法

#### 1、动态规划
假设f(i)表示打劫到房间`i`时的最大收益，nums[i]表示房间`i`的收益，当小偷当地房间`i`时的选择有两种情况：
1. 选择打劫房间`i`，那么他就不能打劫房间`i-1`了，则此时的收益：`f(i - 2) + nums[i]`
2. 选择不打劫房间`i`，那么他可以打劫房间`i-1`，则此时收益：`f(i - 1)`

所以我们只需计算`f(i - 2) + nums[i]`与`f(i - 1)`的最大值即可。状态方程：

```js
f(i) = Math.max(f(i - 2) + nums[i], f(i - 1))
```
> 代码实现：

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
const rob = function(nums) {
  if(nums.length < 1){
    return 0;
  }
  let len = nums.length
  const dp = []
  dp[0] = nums[0]
  dp[1] = nums[1] > nums[0] ? nums[1] : nums[0]
  for (let i = 2; i < len; i++) {
    dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1])
  }
  return dp[len - 1]
};
```

> 时间复杂度空间复杂度：
- 时间复杂度：O(n)
- 空间复杂度：O(n)

> 执行结果：

- 执行用时：`80 ms`，在所有`JavaScript`提交中击败了`41.18 %`的用户
- 内存消耗：`37.6 MB`，在所有`JavaScript`提交中击败了`40.66 %`的用户
